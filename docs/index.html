<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RallyClip | Free Tennis Match Segmentation</title>
    <meta name="description" content="Open-source AI tool that extracts only the rallies from tennis match recordings.">
    <link rel="icon" type="image/png" href="rallyclip_favicon_transparent2.png">
    <link rel="apple-touch-icon" href="rallyclip_favicon_transparent2.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Archivo+Black&family=JetBrains+Mono:wght@400;500&family=Space+Grotesk:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="page">
        <header class="header">
            <p class="byline">A project by <strong>Ismael Robles-Razzaq</strong></p>
            <div class="logo-title-group">
                <img src="rallyclip_logo_cropped.png" alt="RallyClip logo" class="header-logo">
                <h1>RallyClip</h1>
            </div>
            <p class="tagline">Free, open-source tennis match segmentation.<br>Runs entirely on your machine.</p>
            <a href="https://github.com/iroblesrazzaq/RallyClip" class="github-link" target="_blank">GitHub ↗</a>
        </header>

        <nav class="nav">
            <a href="#about">About</a>
            <a href="#motivation">Motivation</a>
            <a href="#how-it-works">How It Works</a>
            <a href="#challenges">Challenges</a>
            <a href="#future">Future</a>
            <a href="#install">Install</a>
        </nav>

        <main class="content">
            <!-- About -->
            <section id="about">
                <h2>What It Does</h2>
                <p>RallyClip takes a full tennis match recording and extracts only the points, removing the dead time between rallies. Drop in a 2-hour match video, get back a condensed video containing just the action, plus an optional CSV with timestamps for each point.</p>
                <p>It works through a pipeline of computer vision and deep learning: court detection, pose estimation with YOLOv8, feature engineering, and a bidirectional LSTM that predicts frame-by-frame whether play is happening. The result is a segmented video with only the rallies, ready for review.</p>
            </section>

            <!-- Motivation -->
            <section id="motivation">
                <h2>Motivation</h2>
                <p>Watching yourself play is one of the best ways to get better at competing in tennis. However, only ~25% of a recorded match is spent "in-point"; the rest is dead time. When you're going through your footage, it's a pain to have to parse through this dead time to get to the actual points.</p>
                <p>Software like SwingVision has tools that accomplish this exactly. However, SwingVision only allows you 2 hours a month free of match segmentation, forcing you to buy their expensive subscription. While SwingVision does have many more analytics, their match segmentation is one of their most popular and useful features.</p>
                <p>I built RallyClip (there's not a ton of tennis/computer vision name schemes so cut me some slack on the name) to solve this problem exactly. <strong>I believe this match segmentation should be made free for anyone to use</strong>, which is why I made RallyClip open-source and local.</p>
                <p>To avoid the costs of cloud compute, you run RallyClip directly on your computer. There are trade-offs with this: this type of video inference is computationally expensive, so running it on your laptop may take some time. I'm using a MacBook Pro M2, and here are the metrics for running it on my laptop. Note that using GPU acceleration significantly improves performance:</p>
                
                <table>
                    <thead>
                        <tr>
                            <th>Model</th>
                            <th>GPU (MPS)</th>
                            <th>CPU</th>
                            <th>Speedup</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>YOLO nano</td>
                            <td>~0.8× video length</td>
                            <td>~3× video length</td>
                            <td>~3.75×</td>
                        </tr>
                        <tr>
                            <td>YOLO small</td>
                            <td>~1.5× video length</td>
                            <td>~7× video length</td>
                            <td>~4.7×</td>
                        </tr>
                    </tbody>
                </table>
                <p class="caption">In other words, GPU acceleration provides ~4× gains, so if you have CUDA or MPS, enable it.</p>
            </section>

            <!-- How It Works -->
            <section id="how-it-works">
                <h2>How It Works</h2>
                
                <h3>1. Court Detection</h3>
                <p>Runs a script to find the lines of the court. Uses classical CV methods to detect lines, then uses heuristics based on the angles of lines to detect the near baseline, singles and doubles sidelines. From those, it creates a court mask of the region where the players would be.</p>
                <p>This enables us to only use bounding boxes from players in the playable area: if there are other players/people on nearby courts, this ensures that we don't use their pose data in our model.</p>
                
                <h3>2. Pose Extraction</h3>
                <p>Runs YOLOv8 pose models on 15 fps downsampled video to extract all potential bounding boxes and keypoint (joints) estimation of players.</p>
                
                <h3>3. Preprocessing & Feature Engineering</h3>
                <p>Preprocess the data: filter out all bounding boxes with centroids not inside our court mask, feature engineer limb lengths, joint velocity and acceleration.</p>
                
                <h3>4. LSTM Inference</h3>
                <p>Create overlapping chunks of 20 seconds, feed into trained bidirectional LSTM, which outputs frame-by-frame probabilities of being in a point vs out of point.</p>
                
                <h3>5. Output Generation</h3>
                <p>Average output signal, apply smoothing and hysteresis filtering to get discrete point start/end times; write these "in-point" chunks to output video.</p>
            </section>

            <!-- Challenges -->
            <section id="challenges">
                <h2>Challenges</h2>
                <p>This project had some decently nontrivial challenges, the main of which were finding a data modality with consistent signal and creating a computationally efficient model that could be run locally.</p>
                
                <h3>Choosing the Data Modality</h3>
                <p>Firstly, I had to decide on a data modality to train my models on.</p>
                <p><strong>Raw video/images:</strong> The pure image/video is computationally infeasible. Training a video transformer or CNN to extract relevant features, even if training on single frames and not including temporal convolutions, would require much more data than I could reasonably gain access to.</p>
                <p><strong>Sound:</strong> Using sound fails for several reasons: (1) Videos with multiple courts make it very difficult to differentiate if the sound of the racket hitting the ball came from the relevant or irrelevant match. (2) Not all shots produce sound, not all players hit hard enough to make loud enough sounds to detect. (3) Sound can be noisy/inconsistent, or a recording may not even have sound.</p>
                <p><strong>Ball tracking:</strong> Ball tracking is doable, but can fail in obfuscation cases, or when the court and ball blend together, it can be very hard to see.</p>
                <p><strong>Player poses:</strong> I finally decided on using player pose data. A point being in play requires the players to move and swing their rackets in distinct patterns. Furthermore, as players will almost certainly be visible in frame during points, they will provide a consistent signal. Lastly, pose extraction is computationally cheap: the YOLOv8-pose models I use are 3.1 and 11.6 million parameters, which result in fast feature extraction.</p>
                
                <h3>Training Data</h3>
                <p>Lastly, there are no publicly available datasets I can use to train on this, so <strong>I manually annotated data for ~8 hours of matches</strong> to train my first models on. I'm quite proud that I built a functioning model trained on such low amounts of data, proof that with clever engineering you can achieve similar results to brute-force big data approaches.</p>
                
                <h3>Limitations</h3>
                <p>If the court detection mask fails and there are more people on the screen than the 2 players, the model could fail as pose detector could pick up on wrong people, and output would be completely unreliable. There are very few cases where this occurs: mainly in low light conditions where classical CV methods fail to detect edges, or where the camera angle is terrible.</p>
                <p>Furthermore, the model could fail to generalize to some videos, likely due to some potential overfitting or insufficient representation of the distribution of match videos. As I collect more data, performance will improve in this regard.</p>
            </section>

            <!-- Future -->
            <section id="future">
                <h2>Future Improvements</h2>
                <ul>
                    <li><strong>Model distillation:</strong> Currently, the YOLO nano pose model is computationally the most feasible, but at the cost of some accuracy compared to YOLO small. I plan to fine-tune the nano YOLO pose model on the outputs of the YOLO large model to close this gap while keeping efficient computation.</li>
                    <li><strong>More data:</strong> I will increase and augment data, using some more hand-labelled data, and using model outputs to create more training data.</li>
                    <li><strong>Attention mechanisms:</strong> As my data increases, I will switch to LSTM with attention, which will improve performance, as it can learn which parts of the 20s window are most relevant with respect to each other.</li>
                    <li><strong>Rally detection:</strong> I will add a rally detection model. My current model doesn't perform as well on this because it has learned that a service or return motion is associated with the start of a point. I'll simply train a model with the same pipeline on rally data instead of match data.</li>
                    <li><strong>Fully installable app:</strong> Make RallyClip a standalone desktop app that requires no terminal commands. Fully non-technical friendly, just download and run.</li>
                    <li><strong>Cloud compute option:</strong> A pay-per-minute cloud service for fast and cheap segmentation. For those who don't want to run it locally or need faster processing.</li>
                </ul>
                <p class="note">If you have any potential improvements, please PR them! I'm super open to feedback and help.</p>
            </section>

            <!-- Install -->
            <section id="install">
                <h2>Installation</h2>
                <p class="requirements">Requires Python 3.10+. 8GB+ RAM recommended. GPU optional (MPS/CUDA supported).</p>
                
                <h3>Using UV (recommended)</h3>
                <p><a href="https://docs.astral.sh/uv/" target="_blank">UV</a> is a fast Python package manager. Install it with <code>curl -LsSf https://astral.sh/uv/install.sh | sh</code></p>
<pre><code><span class="comment"># Clone and install with UV</span>
git clone https://github.com/iroblesrazzaq/RallyClip.git
cd RallyClip
uv sync

<span class="comment"># Run with UV</span>
uv run rallyclip gui
uv run rallyclip --video "match.mp4"</code></pre>

                <h3>Using pip</h3>
<pre><code><span class="comment"># Clone and install with pip</span>
git clone https://github.com/iroblesrazzaq/RallyClip.git
cd RallyClip
python -m venv .venv && source .venv/bin/activate
pip install .</code></pre>
                <p class="caption">Models are included in the repo. YOLO weights auto-download on first run.</p>
            </section>

            <!-- Usage -->
            <section id="usage">
                <h2>Usage</h2>
                <p class="caption">If installed with UV, prefix commands with <code>uv run</code>. If installed with pip, run directly after activating your venv.</p>
                
                <h3>GUI</h3>
                <p>Launch the browser-based interface:</p>
<pre><code>rallyclip gui          <span class="comment"># pip install</span>
uv run rallyclip gui   <span class="comment"># uv sync</span></code></pre>
                <p>Drag and drop your video, adjust settings if needed, and download the result. The GUI provides real-time progress tracking and advanced settings.</p>
                
                <h3>CLI</h3>
<pre><code><span class="comment"># Basic usage (only video path required)</span>
rallyclip --video "match.mp4"

<span class="comment"># With CSV output</span>
rallyclip --video "match.mp4" --write-csv

<span class="comment"># Custom output directory</span>
rallyclip --video "match.mp4" --output-dir "./processed"

<span class="comment"># Use config file for all options</span>
rallyclip --config config.toml</code></pre>
                <p>See the <a href="https://github.com/iroblesrazzaq/RallyClip#readme" target="_blank">README</a> for full CLI options and config file documentation.</p>
            </section>
        </main>

        <footer class="footer">
            <a href="https://github.com/iroblesrazzaq/RallyClip" target="_blank">GitHub</a>
            <span>·</span>
            <a href="https://github.com/iroblesrazzaq/RallyClip/issues" target="_blank">Issues</a>
            <span>·</span>
            <span>GPL-3.0 License</span>
        </footer>
    </div>

    <script>
        (function () {
            const group = document.querySelector('.logo-title-group');
            const title = group?.querySelector('h1');

            if (!group || !title) return;

            const syncLogoWidth = () => {
                const width = title.getBoundingClientRect().width;

                if (width > 0) {
                    group.style.setProperty('--logo-width', `${width}px`);
                }
            };

            const setupObservers = () => {
                if (window.ResizeObserver) {
                    const observer = new ResizeObserver(syncLogoWidth);
                    observer.observe(title);
                }

                window.addEventListener('resize', syncLogoWidth);
            };

            const init = () => {
                syncLogoWidth();
                setupObservers();
            };

            if (document.fonts?.ready) {
                document.fonts.ready.then(init);
            } else if (document.readyState === 'complete') {
                init();
            } else {
                window.addEventListener('load', init, { once: true });
            }
        })();
    </script>
</body>
</html>
